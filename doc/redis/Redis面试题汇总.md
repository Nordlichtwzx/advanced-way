### Redis面试题汇总



###### Redis是什么

Redis是由c语言开发的，开源的，高性能的，非关系型的，键值对内存数据库，可以用做数据库缓存，消息中间件等



###### 为什么使用Redis

​		因为传统的关系型数据库如mysql已经不能满足所有的场景了，比如对于一些访问频率较高的数据，如果每次都去数据库中查询很容易把数据库打崩，所以引入了缓存中间件，目前市面上比较常用的缓存中间件有Redis和Memcached



###### Redis和Memachaed的区别

*   Redis支持持久化，但是Memachaed不支持，如果机器掉电，数据就会全部丢失
*   Memachaed只支持简单的key-value，但是Redis支持五种数据类型
*   value的大小，Redis可以支持1G，但是Memachaed只支持1M



###### Redis中的数据类型

| 类型      | 简介                                                  | 特性                                                         | 场景                                 |
| --------- | ----------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------ |
| string    | 二进制安全，可以存储任何数据，最大存储512M            | 可以包含任何数据，比如图片，或者可序列化的对象               | 可以用到的场景很多                   |
| hash      | 键值对集合，即java中的map类型                         | 适合存储对象，并且可以像数据库中的update一样，只修改某一个特性的值 | 可以用来存储对象                     |
| list      | 双向链表                                              | 增删块，两头都可以操作                                       | 可以用来实现一个简单的消息队列，     |
| set       | hash表实现，元素不重复                                | 增删改查的复杂度都为O(1)，并且提供了求交集，并集，差集的操作 | 可以利用唯一性，统计访问网站的所有IP |
| sortedset | 给set的元素添加一个权重参数，score，元素按照score排列 | 元素是唯一且有序的                                           | 可以用来做排行榜，或者延时队列       |
|           |                                                       |                                                              |                                      |

###### 如果有大量key在同一时间失效，一般需要注意什么

如果大量key在同一时间失效，Redis会出现短暂的卡顿现象，严重的话会导致**缓存雪崩**，所以我们需要对时间加一个随机值，使得过期时间分散一下



###### Redis分布式锁

先拿setnx来获取锁，然后用expire给这个锁添加一个失效时间，防止锁忘记释放

为了避免在setnx后系统宕机，可以将setnx和expire一起执行

```xml
 SET resource-name anystring NX EX max-lock-time
```



###### 如何匹配的找出某些key？如果需要匹配的数据量很大，会出现什么现象？

可以使用keys指令扫出指定模式的key列表

但由于Redis是单线程的，如果使用keys指令可能会导致线上服务出现停顿，直到指令执行完毕服务才能恢复，**所以**，可以使用scan指令来代替keys，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定重复的概率，需要在客户端做一次去重。



###### 使用Redis做过异步队列吗

可以使用Redis中的list数据结构来实现，rpush生产消息，lpop消费消息，当老婆婆没有消息的时候，需要适当的sleep一会再重试。



###### 可以不用sleep吗？

可以使用blpop或者brpop，在没有消息的时候他会阻塞直到消息到来。



###### 可以一次生产，多次消费吗？

可以使用pub/sub（发布订阅），实现1:N的消息队列



###### pub/sub有什么缺点

pub/sub模式只负责发布消息，如果客户端失去连接会造成消息丢失



###### Redis如何实现延时队列

可以使用sortedset，拿时间戳作为score，消息内容作为key调用zadd指令来生产消息，消费者用zrangebyscore指令获取N秒之前的数据轮训进行处理



###### Redis怎么持久化的？服务主从数据是怎么交互的？

Redis有两种持久化的方式，一种是RDB做镜像全量持久化，一种是AOF做增量持久化。因为RDB会耗费较长时间，不够实时，在停机后会导致数据丢失，所以需要配合AOF来使用，在Redis实例重启时，会使用RDB持久化文件重新构建内存，再使用AOF重放近期操作指令来实现数据完整恢复到重启前的状态

主从复制就是利用这一特点，首先slave向master发送请求，然后master执行bgsave指令生成RDB文件，将RDB文件通过socket连接发送给slave，slave接收到RDB文件后进行全量复制。但在执行bgsave指令的过程中会有其他指令执行，这时将这些指令记录在复制缓冲区，然后master通过socket将复制缓冲区中的指令发送给slave，slave调用bgrewriteaof指令，执行这些指令，完成部分复制。



###### 缓存雪崩

在同一时间，大量的key失效，导致所有的请求都直接打在了数据库

**解决办法：**在往Redis存储数据的时候需要给key的失效时间添加一个随机值，防止大面积的过期。或者设置缓存中的数据永不失效，有更新操作就更新缓存。



###### 缓存穿透

缓存和数据库中都没有的数据，但是用户对改数据不断发送请求，比如说我们的id都是自增的，如果用户一直请求id=-1的值，那么会导致数据库压力变大，严重会导致数据库崩溃。

因为数据库和缓存中都没有该数据，所以每次请求都会直接打到数据库上，相当于Redis不存在，如果不断发起请求就会造成数据库的压力

**解决办法：**

1.  对于缓存穿透，我们可以在代码层面进行用户鉴权，参数校验，如果没有通过，直接返回。
2.  或者也可以使用Bloom过滤器，如果数据在数据库中不存在，那么直接返回，如果存在，就取查询DB，刷新KV再返回



###### 缓存击穿

对于一个热点数据，有大量的请求都针对这个数据，当某一瞬间这个热点数据失效，那么就会有大量的请求直接打在数据库上

**解决办法：**可以设置该数据永不过期，**或者可以使用分布式锁？？？？**



###### Redis为什么这么快

*   Redis完全基于内存实现的，绝大部分请求时纯粹的内存操作，非常迅速，数据存在内存中，类似于hashmap，hashmap的优势就是查找和操作的时间复杂度就是O(1)
*   数据结构简单，对数据操作也简单
*   采用单线程，避免了不必要的上下文切换和竞争条件，不存在多线程切换导致的CPU性能消耗，不用考虑各种锁的问题
*   使用多路复用IO模型，非阻塞IO



###### Redis的淘汰策略

*   检测有失效时间的值
    *   volatile-lru：最近最久未使用（**常用**）
    *   volatile-lfu：最近最少次数使用
    *   volatile-ttl：挑选将要过期的数据
    *   volatile-random：随机挑选数据
*   检测全库数据
    *   allkeys-lru：最近最久未使用
    *   allkeys-lfu：最近最少次数使用
    *   allkeys-random：随机删除
*   放弃驱逐
    *   no-enviction：禁止驱逐数据



###### Redis的删除策略

*   定时删除

    需要使用定时器定时扫描数据，对cpu的消耗较大，对内存的消耗较少

*   惰性删除

    在每次使用key之前判断是否过期，如果没有过期返回数据，如果过期则返回不存在，同时删除expires中的数据和内存中对应地址的数据

*   定期删除

    <!--这里还需要补充-->





###### Redis的持久化

**RDB：**

**AOF：**











