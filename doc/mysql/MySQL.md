# MySQL

## 1. 索引

### 1.1 索引概述

​		MySQL官方对索引的定义为：索引（index）是帮助MySQL高效获取数据的数据结构（有序）。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引

![](images\索引.png)

### 1.2 索引优劣

**优势**

1. 类似于书籍的目录索引，提高数据检索效率的同时，降低数据库的IO成本
2. 通过索引对列数据进行排序，降低数据排序的成本，降低CPU的消耗

**劣势**

1. 索引会占据额外的磁盘空间
2. 索引会影响更新表的速度，因为在更新表数据的同时也需要更新索引。

### 1.3 索引结构

索引是在MySQL的存储引擎层中实现的，而不是在服务器层，所以每种存储引擎支持的索引都不完全一样，也不是所有的存储引擎都支持所有的索引类型

![](images\引擎索引.png)

### 1.4 BTREE结构

BTree又叫多路平衡搜索树，一颗m叉的BTree特性如下

* 树中每个节点最多包含m个孩子
* 除根节点与叶子结点外，每个节点至少是有[ceil(m/2)]（向上取整）个孩子
* 若根节点不是叶子节点，则至少有两个还在孩子
* 所有的叶子结点都在同一层
* 每个非叶子节点由n个key与n+1个指针组成，其中[ceil(m/2)-1]<=n<=m-1

### 1.5 B+树

* n叉B+树最多有n个key
* B+ 树的叶子结点保存key所在节点的信息，按照key大小排列
* 所有的非叶子结点都可以看作是key的索引部分

#### MySQL中的B+树

MySQL的B+树对经典的B+树进行了优化，在原有B+树的基础上，**增加了一个指向相邻叶子结点的链表指针**，就形成了带有顺序指正的B+树，这样可以提高区间访问的性能。

![](images\mysqlb+.png)

### 1.6 索引分类

1. 单值索引：即一个索引只包含单个列，一个表可以有多个单列索引
2. 唯一索引：索引列的值必须唯一，但允许有空值
3. 符合索引，即一个索引包含多个列

### 1.7 索引设计原则

* 对查询频次高，且数据量大的表建立索引
* 索引字段的选择，最佳候选列应当从where子句的条件中提取，如果where子句中的组合较多，那么应该挑选最常用、过滤效果最好的列的组合
* 使用唯一索引，区分度越高，使用索引的效率越高
* 索引不是多多益善，索引越多需要额外维护的成本就越高。**索引过多**会引入相当高的维护代价，降低DML操作的效率。另外索引过多的话，MySQL也会犯选择困难症，提高了选择的代价
* 使用段索引，因为索引也会占据额外的磁盘空间，段所有可以有效提升MySQL访问索引的I/O效率
* 利用最左前缀，组合索引。

## 2. 存储引擎

### 2.1 存储引擎概述

​		和大多数数据库不同，MySQL中有一个存储引擎的概念，针对不同的存储需求可以选择最优的存储引擎。存储引擎就是存储数据，建立索引，更新查询数据等等技术的实现方式，**存储引擎是基与表的，而不是基于库的**，所以存储引擎也可被称为表类型



MySQL支持多种存储引擎，可以使用下面的命令来查看

```mysql
show engines;
```

![](images\存储引擎.png)

也可以使用下面的命令来查看默认的存储引擎

```mysql
show variables like '%storage_enagine%';
```

![](images\默认存储引擎.png)

### 2.2 各种存储引擎

![](images\多种存储引擎.png)

#### 2.2.1 InnoDB

**支持**

1. 事务控制：MySQL中默认支持的事务隔离级别为可重复读，所以在操作数据库时如果使用了事务，但是没有提交事务，再用其他的客户端查看时是查询不到更新后的事务的。

2. 外键约束：支持外键约束

   删除主表数据时，如果有关联记录，则不删除

   ```mysq
   ON DELEET RESTRICET 
   ```

   更新主表时，如果子表有关联记录，则更新子表

   ```mysql
   ON UODATE CASCADE
   ```

3. 存储方式

   InnoDB存储表和索引有一下两种方式

   1. 使用共享表空间存储，这种方式创建的表结构保存在**.frm**文件中，数据和索引保存在innodb_data_home_dir和innodb_data_file_path定义的表空间中，可以是多个文件
   2. 使用多表空间存储，这种方式创建的表的表结构依然存储在**.frm**文件中，但是每个表的数据和索引单独保存在.**ibd**中

   ![](images\保存位置.png)

#### 2.2.2 MyISAM

MyISAM不支持事务，也不支持外键，其优势是访问的速度快，对事务的完整性没有要求或者以select、insert为主的应用基本带上都可以使用这个引擎

**不支持**

  1.   不支持事务：没有事务控制

  2.   存储方式：

       1. .frm：存储表定义
       2. .MYD：（MYData，存储数据）
       3. .MYI：（MYIndex，存储索引）

       ![](images\myisam存储文件.png)

#### 2.2.3 Memory

Memory存储引擎将表的数据存放在内存中，每个Memory表实际对应一个磁盘文件，**.frm**该文件中只存储表的结构。因为Memory引擎中的数据都存放在内存中，所以读取速度很快，并且默认使用HASH索引。但是服务一旦关闭，数据就会丢失

#### 2.2.4 MERGE

MERGE存储引擎是一组MyISAM表的组合，这些表结构必须完全相同，MERGE本身不存储数据，对MERGE表进行的增删改操作内部都是对MyISAM表的操作![](images\merge.png)

## 3. 优化SQL步骤

### 3.1 查看SQL执行频率

MySQL客户端连接成功后，通过show [session|global]命令可以提供服务状态信息。show[session|global] status可以根据需要加上参数“session”或者“global”来显示session级（当前连接）的结果和global级（自数据库上次启动至今）的统计结果，如果不写，默认使用参数是“session”

```mysql
show status like 'Com_______'(7个)
```

![](images\123.png)

```mysql 
show status like 'Innodb_rows_%';
```

![](images\Innodb查询.png)

### 3.2 定位低效率执行SQL

* 慢查询日志：通过慢查询日志定位那些执行效率较低的SQL语句，用--log-slow-queries[=file_name]选项启动时，mysql写一个包含所有执行时间超过long_query_time秒的SQL语句的日志文件

* show processlist：慢查询日志是在查询结束后才记录，所以在应用反映执行效率出现问题的时候慢查询日志并不能定位问题，可以使用show processlist命令查看档期那MySQL正在执行的线程，包括线程的状态，是否锁表等，可以实时的查看SQL的执行情况，同时进行一些优化

  ![](images\preocesslis.png)

### 3.3 explain分析执行计划

#### 3.3.1 explain之id

id字段是select查询的序列号，是一组数字，表示的是查询中执行select子句或者是操作表的顺序，id的情况有三种

1. id相同表示加载表的顺序是从上到下

   ![](images\id相同.png)

2. id不同id值越大，优先级越高，越先被执行

   ![](images\id不同.png)

3. id有相同，也有不同，同时存在，id相同的可以认为是一组，从上往下顺序执行；在所有的组中，id的值越大，优先级越高，越先执行

   ![](images\id同不同.png)

#### 3.3.2 explain之select_type



**从上往下执行效率越来越低**



| select_type  | 含义                                                         | 图解                                |
| ------------ | ------------------------------------------------------------ | ----------------------------------- |
| SIMPLE       | 简单的select查询，查询中不包含子查询或者union                | <img src="images\simple.png"  />  |
| PRIMARY      | 查询中若包含任何复杂的子查询，最外层查询标记为该标识         | ![](images\primary——subquery.png) |
| SUBQUERY     | 在SELECT或where列表中包含了子查询                            | ![](images\primary——subquery.png) |
| DERIVED      | 在FROM列表中包含的子查询，被标记为DERIVED（衍生）MySQL会递归执行这些资讯查询，把结果放在临时表中 | ![](images\derived.png)           |
| UNION        | 若第二个select出现在union之后，则标记为union；若union包含在from子句的子查询中，外层select将被标记为：DERIVED | ![](images\union.png)             |
| UNION RESULT | 从UNION表获取结果的SELECT                                    | ![](images\union.png)             |
|              |                                                              |                                     |

#### 3.3.3 explain之table

展示这一行的数据是关于哪一张表的

#### 3.3.4explain之type



**从上往下执行效率越低，一般来说，我们只需要保证查询至少达到染个级别，最好达到ref**

| type   | 含义                                                         |
| ------ | ------------------------------------------------------------ |
| NULL   | MySQL不访问任何表，索引，直接返回数据，比如返回当前数据select now() |
| system | 表只有一行记录(等于系统表)，这是const类型的特例，一般不会出现 |
| const  | 表示通过索引一次就找到了，const用于比较primary key或者unique索引。因为只匹配一行数据，所以很快。如将主键置于社热列表中，MySQL就能将该查询转换为一个常量，const会将主键或唯一索引的所有部分与常量值进行比较 |
| eq_ref | 类似ref，区别在于使用的是唯一索引，使用主键的关联查询，关联查询出的记录只有一条，常见于主键或唯一索引扫描 |
| ref    | 非唯一索引扫描，返回匹配某个单独值得所有行，本质上也是一种索引访问，返回所有匹配某个单独值得所有行（多个） |
| range  | 只检索给定返回的行，使用一个索引来选择行，where之后出现between，<,>,in等操作，用于范围查询 |
| index  | index与ALL的区别为index类型只是遍历了索引树，通常比ALL快，ALL是遍历数据文件。比如说select id from table，这里的id是主键索引，这样就会遍历索引树查找出所有的id。 |
| all    | 将遍历全表以找打匹配的行                                     |
|        |                                                              |

#### 3.3.5 explain之key

1. possible_keys：显示可能应用在这张表上的索引，一个或者多个
2. key：实际使用的索引，如果为NULL，则没有使用到索引
3. key_len：表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好

#### 3.3.6explain之rows、

扫描的行数

#### 3.3.7explain之extra



| extra          | 含义                                                         |
| -------------- | ------------------------------------------------------------ |
| using filesort | 说明MySQL会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取，称为：文件排序，效率低 |
| using tempary  | 使用了临时表保存中间结果，MySQL在对查询结果排序是使用临时表，常见于order by和group by；效率低 |
| using index    | 表示相应的select操作使用了覆盖索引，避免访问表的数据行，效率不错（索引命中） |
|                |                                                              |

### 3.4 show profile分析SQL

**MySQL从5.0.37版本开始增加了对show profiles和show profile 的支持，帮助我们知道SQL时间都耗费在了哪里**

1. 设置profile

   1. 查看是否有profile功能

      ```mysql
      show @@have_profiling;
      ```

   2. 查看当前profile是否开启

      ```mysql
      select @@profiling;
      ```

   3. 打开profile

      ```mysql
      set @@profiling = 1;
      ```

   ![](images\profiling.png)

2. 执行show profiles指令，来查看SQL语句执行的耗时

   ![](images\showprfiles.png)

3. 查看单个耗时较多的SQL语句具体的耗时

   ![](images\单独profiles.png)

### 3.5 trace

![](images\trace.png)

![](images\trace一部分.png)



## 4.索引的使用

### 4.1 避免索引失效

1. 全值匹配：对索引中所有列都指定具体指。索引生效，执行效率高。

2. 最左前缀法则：如果索引是多列，要遵守最左前缀法则，值得是查询从索引的最左前列开始，并且不跳过索引中的列

3. **范围查询右边的列，索引失效**

4. **不要在索引列上进行运算操作，索引失效**

5. **字符串不加单引号，造成索引失效。如果MySQL发现varchar类型的字段没有加单引号，会对该字符串进行隐式类型转换，这样就会导致该索引类使用了运算操作，就会失效。**

6. 尽量使用覆盖索引，避免select *，避免回表查询。

   **MySQL5.6引入的<u>索引下推优化</u>，可以在索引遍历过程中，对索引包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。**

   > using index：使用覆盖索引的时候就会出现
   >
   > using where：在查找使用索引的情况下，需要回表去查询所需的数据
   >
   > using index condition：查找使用了索引，但是需要回表查询的数据
   >
   > using index；using where：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询。

7. **用or分割开的条件，如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引搜不会被用到，索引失效**

8. **以%开头的like模糊查询，索引失效。可以通过覆盖索引来解决。**

9. 如果MYSQL评估使用索引比权标更慢，则不使用索引。比如说某一列的数据中某一个值占的比例特别大，那么就不会走索引，就会直接走全表扫描。

10. is NULL，is NOT NULL有时索引失效，这主要取决于该列数据中NULL值得多少，如果NULL值占比特别大，那么is NOT NULL就会走索引，相反is NULL走索引。**这主要取决于一个值在所在列所占的数据量大小，这是MySQL后台优化后的结果，和第9点一样，都是优化后决定是否使用索引，取决于该值在所在列中的占比**

11. in 走索引，not in不走索引

12. 单列索引和复合索引的选择

    尽量使用复合索引，而少用单列索引，创建复合索引

    ![](images\复合.png)

    创建单列索引

    ![](images\单列.png)

    数据库会选择一个最优的索引（辨识度最高的索引）来使用，并不会使用全部索引



### 4.2 查看索引使用的情况

![](images\查看索引.png)